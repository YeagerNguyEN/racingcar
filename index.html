<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Racer</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        background: linear-gradient(to bottom, #1a1a1a, #000000);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: hidden;
        font-family: "Orbitron", sans-serif;
        color: #0ff;
      }
      canvas {
        border-radius: 15px;
        box-shadow: 0 0 40px rgba(0, 255, 255, 0.7);
        background: #050505;
        touch-action: none;
      }
      #score {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #0ff;
        font-size: 28px;
        font-weight: 700;
        text-shadow: 0 0 10px #0ff, 0 0 20px rgba(0, 255, 255, 0.5);
        z-index: 10;
      }
      #gameOverScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #0ff;
        font-size: 42px;
        font-weight: 900;
        text-align: center;
        display: none;
        user-select: none;
        z-index: 20;
        background: rgba(0, 0, 0, 0.7);
        padding: 30px;
        border-radius: 20px;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
      }
      #restartBtn {
        margin-top: 25px;
        padding: 15px 40px;
        font-size: 24px;
        background: #0ff;
        color: #000;
        border: none;
        border-radius: 15px;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        transition: background 0.3s ease, box-shadow 0.3s ease;
        font-family: "Orbitron", sans-serif;
        font-weight: 700;
      }
      #restartBtn:hover {
        background: #0af;
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
      }
    </style>
  </head>
  <body>
    <div id="score">Score: 0</div>
    <div id="gameOverScreen">
      GAME OVER<br />
      <button id="restartBtn">Restart</button>
    </div>
    <canvas id="gameCanvas" width="400" height="700"></canvas>

    <script>
      // --- Game Constants and DOM Elements ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreDiv = document.getElementById("score");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const restartBtn = document.getElementById("restartBtn");

      const LANE_COUNT = 3;
      const LANE_WIDTH = canvas.width / LANE_COUNT;
      const LANE_CENTERS = Array.from(
        { length: LANE_COUNT },
        (_, i) => LANE_WIDTH * (i + 0.5)
      );

      const ROAD_LINE_HEIGHT = 80;
      const ROAD_LINE_WIDTH = 10;
      const ROAD_LINE_SPACING = 160;

      const PLAYER_WIDTH = 50;
      const PLAYER_HEIGHT = 100;
      const ENEMY_WIDTH = 50;
      const ENEMY_HEIGHT = 100;

      // Khoảng cách tối thiểu giữa các "hàng" kẻ thù
      const ENEMY_SPAWN_GAP = ENEMY_HEIGHT * 1.8;

      // --- Game State Variables ---
      let roadLines = [];
      let enemies = [];
      let score = 0;
      let gameSpeed = 6;
      let gameRunning = false;
      let animationFrameId = null;

      const player = {
        width: PLAYER_WIDTH,
        height: PLAYER_HEIGHT,
        x: LANE_CENTERS.at(1) - PLAYER_WIDTH / 2,
        y: canvas.height - 140,
        lane: 1,
      };

      const keys = { ArrowLeft: false, ArrowRight: false };

      // --- Helper Functions for Drawing ---

      function drawCarShape(
        ctx,
        x,
        y,
        width,
        height,
        bodyColor,
        windowColor,
        shadowColor
      ) {
        ctx.save();
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = 15;

        // Car body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.moveTo(x + width * 0.2, y);
        ctx.lineTo(x + width * 0.8, y);
        ctx.quadraticCurveTo(
          x + width,
          y + height * 0.2,
          x + width,
          y + height * 0.6
        );
        ctx.quadraticCurveTo(
          x + width,
          y + height * 0.9,
          x + width * 0.8,
          y + height
        );
        ctx.lineTo(x + width * 0.2, y + height);
        ctx.quadraticCurveTo(x, y + height * 0.9, x, y + height * 0.6);
        ctx.quadraticCurveTo(x, y + height * 0.2, x + width * 0.2, y);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 10;
        // Windows
        ctx.fillStyle = windowColor;
        ctx.beginPath();
        ctx.moveTo(x + width * 0.25, y + height * 0.1);
        ctx.lineTo(x + width * 0.75, y + height * 0.1);
        ctx.lineTo(x + width * 0.7, y + height * 0.45);
        ctx.lineTo(x + width * 0.3, y + height * 0.45);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 5;
        ctx.fillStyle = "#111";
        // Wheels
        ctx.beginPath();
        ctx.arc(
          x + width * 0.15,
          y + height * 0.25,
          width * 0.1,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.beginPath();
        ctx.arc(
          x + width * 0.85,
          y + height * 0.25,
          width * 0.1,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.beginPath();
        ctx.arc(
          x + width * 0.15,
          y + height * 0.85,
          width * 0.1,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.beginPath();
        ctx.arc(
          x + width * 0.85,
          y + height * 0.85,
          width * 0.1,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.restore();
      }

      function drawPlayer() {
        drawCarShape(
          ctx,
          player.x,
          player.y,
          player.width,
          player.height,
          "#ff0055", // Neon pink
          "#88ffff",
          "#ff0055"
        );
      }

      function drawEnemy(enemy) {
        drawCarShape(
          ctx,
          enemy.x,
          enemy.y,
          enemy.width,
          enemy.height,
          "#00aaff", // Neon blue
          "#ffccff",
          "#00aaff"
        );
      }

      // --- Road and Environment ---

      function initRoadLines() {
        roadLines = [];
        for (
          let i = 0;
          i < Math.ceil(canvas.height / ROAD_LINE_SPACING) + 2;
          i++
        ) {
          roadLines.push({
            x: canvas.width / 2 - ROAD_LINE_WIDTH / 2,
            y: i * ROAD_LINE_SPACING - ROAD_LINE_HEIGHT,
          });
        }
      }

      function drawRoadLines() {
        ctx.fillStyle = "#0ff";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 8;
        roadLines.forEach((line) => {
          ctx.fillRect(line.x, line.y, ROAD_LINE_WIDTH, ROAD_LINE_HEIGHT);
        });
        ctx.shadowBlur = 0;
      }

      function moveRoadLines() {
        roadLines.forEach((line) => {
          line.y += gameSpeed;
          if (line.y > canvas.height) {
            line.y -= roadLines.length * ROAD_LINE_SPACING;
          }
        });
      }

      function drawRoad() {
        // Dark background
        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Road surface
        ctx.fillStyle = "#1c1c1c";
        ctx.fillRect(
          LANE_WIDTH * 0.05,
          0,
          LANE_WIDTH * LANE_COUNT * 0.9,
          canvas.height
        );

        // Neon side stripes
        ctx.fillStyle = "#0ff";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 10;
        ctx.fillRect(LANE_WIDTH * 0.05 - 5, 0, 5, canvas.height);
        ctx.fillRect(LANE_WIDTH * LANE_COUNT * 0.9, 0, 5, canvas.height);
        ctx.shadowBlur = 0;

        // Simple background buildings/horizon
        ctx.fillStyle = "#2a2a2a";
        ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
        ctx.fillStyle = "#1a1a1a";
        for (let i = 0; i < 10; i++) {
          ctx.fillRect(
            Math.random() * canvas.width,
            canvas.height - 100 - Math.random() * 80,
            20 + Math.random() * 30,
            20 + Math.random() * 80
          );
        }
      }

      // --- Enemy Management ---

      function createEnemies(initialCount) {
        enemies = [];
        for (let i = 0; i < initialCount; i++) {
          spawnNewEnemyRow(i * ENEMY_SPAWN_GAP * 1.5 + ENEMY_HEIGHT * 2);
        }
      }

      function spawnNewEnemyRow(currentY) {
        const emptyLane = Math.floor(Math.random() * LANE_COUNT);
        const lanesToBlock = [];
        for (let i = 0; i < LANE_COUNT; i++) {
          if (i !== emptyLane) {
            lanesToBlock.push(i);
          }
        }

        const numberOfEnemies = Math.random() < 0.6 ? 1 : 2; // 60% tạo 1 xe, 40% tạo 2 xe
        const lanesToUse = [];

        // Chọn ngẫu nhiên 'numberOfEnemies' làn từ 'lanesToBlock'
        while (lanesToUse.length < numberOfEnemies && lanesToBlock.length > 0) {
          const randomIndex = Math.floor(Math.random() * lanesToBlock.length);
          lanesToUse.push(lanesToBlock.splice(randomIndex, 1)[0]);
        }

        lanesToUse.forEach((lane) => {
          enemies.push({
            lane: lane,
            width: ENEMY_WIDTH,
            height: ENEMY_HEIGHT,
            x: LANE_CENTERS.at(lane) - ENEMY_WIDTH / 2,
            y: -currentY,
          });
        });
      }

      function moveEnemies() {
        const enemiesToKeep = [];
        let newEnemiesToAddCount = 0;
        let highestEnemyY = canvas.height;
        if (enemies.length > 0) {
          highestEnemyY = Math.min(...enemies.map((e) => e.y));
        }

        for (let i = 0; i < enemies.length; i++) {
          const enemy = enemies.at(i);
          enemy.y += gameSpeed;

          if (enemy.y > canvas.height + enemy.height) {
            score++;
            gameSpeed += 0.005;
            if (enemy.y - ENEMY_HEIGHT * 1.5 > highestEnemyY) {
              newEnemiesToAddCount++;
            }
          } else {
            enemiesToKeep.push(enemy);
          }
        }
        enemies = enemiesToKeep;

        for (let i = 0; i < newEnemiesToAddCount; i++) {
          spawnNewEnemyRow(canvas.height + ENEMY_SPAWN_GAP * (i + 1));
        }
      }

      function drawEnemies() {
        enemies.forEach(drawEnemy);
      }

      function checkCollision() {
        for (const enemy of enemies) {
          if (
            player.lane === enemy.lane &&
            enemy.y + enemy.height > player.y + 10 &&
            enemy.y < player.y + player.height - 10
          ) {
            return true;
          }
        }
        return false;
      }

      // --- Input Handling (Unified) ---

      function changePlayerLane(direction) {
        if (direction === "left" && player.lane > 0) {
          player.lane--;
          player.x = LANE_CENTERS.at(player.lane) - PLAYER_WIDTH / 2;
        } else if (direction === "right" && player.lane < LANE_COUNT - 1) {
          player.lane++;
          player.x = LANE_CENTERS.at(player.lane) - PLAYER_WIDTH / 2;
        }
      }

      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          changePlayerLane("left");
        } else if (e.key === "ArrowRight") {
          changePlayerLane("right");
        }
      });

      let touchStartX = 0;
      const SWIPE_THRESHOLD = 30;

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
          touchStartX = e.touches.at(0).screenX;
        }
      });

      canvas.addEventListener("touchend", (e) => {
        if (e.changedTouches.length === 1) {
          const touchEndX = e.changedTouches.at(0).screenX;
          if (touchEndX < touchStartX - SWIPE_THRESHOLD) {
            changePlayerLane("left");
          } else if (touchEndX > touchStartX + SWIPE_THRESHOLD) {
            changePlayerLane("right");
          }
        }
      });

      // --- Game Loop and Control ---

      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function gameLoop() {
        if (!gameRunning) {
          cancelAnimationFrame(animationFrameId);
          return;
        }

        clearCanvas();
        drawRoad();
        moveRoadLines();
        drawRoadLines();
        moveEnemies();
        drawEnemies();
        drawPlayer();

        scoreDiv.textContent = "Score: " + score;

        if (checkCollision()) {
          endGame();
          return;
        }

        animationFrameId = requestAnimationFrame(gameLoop);
      }

      function startGame() {
        score = 0;
        gameSpeed = 6;
        player.lane = 1;
        player.x = LANE_CENTERS.at(player.lane) - PLAYER_WIDTH / 2;
        initRoadLines();
        createEnemies(3); // Bắt đầu với 3 "hàng" kẻ thù ban đầu
        gameOverScreen.style.display = "none";
        scoreDiv.style.display = "block";
        gameRunning = true;
        animationFrameId = requestAnimationFrame(gameLoop);
      }

      function endGame() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        gameOverScreen.style.display = "block";
        scoreDiv.style.display = "none";
      }

      restartBtn.addEventListener("click", () => {
        startGame();
      });

      // Initial game start
      startGame();
    </script>
  </body>
</html>
